
 1. Subqueries
postgres=# SELECT first_name, last_name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);

postgres=# SELECT first_name, last_name, salary FROM employees WHERE (first_name, last_name, salary) = (SELECT first_name, last_name, MAX(salary) FROM employees);

 Table subquery: returns multiple rows/columns
 Example: find employees in departments with more than 10 employees
postgres=# SELECT first_name, last_name, department_id FROM employees WHERE department_id IN (SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(*) > 10);


 2. Common Table Expressions (CTEs)

postgres=# WITH regional_sales AS (SELECT region_id, SUM(amount)
AS total_sales FROM orders GROUP BY region_id) SELECT region_id, total_sales FROM regional_sales WHERE total_sales > 1000000;
postgres=# WITH dept_avg AS (SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department) 
SELECT e.first_name, e.salary, d.avg_salary FROM employees e INNER JOIN dept_avg d ON e.department = d.department WHERE e.salary > d.avg_salary;


 3. Recursive Queries

 Recursive CTE to get hierarchical org chart
postgres=# WITH RECURSIVE org_chart AS (
    SELECT employee_id, first_name, last_name, manager_id FROM employees WHERE manager_id IS NULL
    UNION ALL
    SELECT e.employee_id, e.first_name, e.last_name, e.manager_id FROM employees e INNER JOIN org_chart oc ON e.manager_id = oc.employee_id
) SELECT * FROM org_chart;


 4. Set Operations

UNION: 
postgres=# SELECT product_name FROM warehouse_1 UNION SELECT product_name FROM warehouse_2;

UNION ALL: 
postgres=# SELECT product_name FROM warehouse_1 UNION ALL SELECT product_name FROM warehouse_2;

INTERSECT: 
postgres=# SELECT product_id FROM warehouse_1 WHERE quantity = 0 INTERSECT SELECT product_id FROM warehouse_2 WHERE quantity = 0;

EXCEPT: 
postgres=# SELECT product_id FROM warehouse_1 EXCEPT SELECT product_id FROM warehouse_2;


5. Window Functions & Partitioning

postgres=# SELECT first_name, last_name, department, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_salary_rank FROM employees;

Use FILTER 
postgres=# SELECT employee_id, SUM(salary) OVER (PARTITION BY department) AS total_dept_salary, AVG(salary) 
FILTER (WHERE tenure > 5) OVER () AS avg_salary_senior FROM employees;

Example with LAG() 
postgres=# SELECT employee_id, first_name, salary, LAG(salary) 
OVER (PARTITION BY department ORDER BY salary) AS prev_salary FROM employees;


6. Pivot Operations (Conditional Aggregation)

postgres=# SELECT product_name, SUM(CASE WHEN year = 2022 THEN sales_amount ELSE 0 END) AS year_2022, 
SUM(CASE WHEN year = 2023 THEN sales_amount ELSE 0 END) AS year_2023, 
SUM(CASE WHEN year = 2024 THEN sales_amount ELSE 0 END) AS year_2024 FROM sales GROUP BY product_name;


7. Unpivot Operations (using UNION ALL)

Turn columns into rows
postgres=# SELECT product_name, '2022' AS year, year_2022 AS sales_amount FROM pivoted_sales
UNION ALL
SELECT product_name, '2023' AS year, year_2023 AS sales_amount FROM pivoted_sales
UNION ALL
SELECT product_name, '2024' AS year, year_2024 AS sales_amount FROM pivoted_sales
ORDER BY product_name, year;


8. Complex Filtering & Sorting

Custom sort using CASE
postgres=# SELECT product_name, status FROM orders ORDER BY CASE status WHEN 'High Priority' THEN 1 WHEN 'Medium Priority' THEN 2 WHEN 'Low Priority' THEN 3 ELSE 4 END;
postgres=# SELECT employee_id, SUM(salary) OVER (PARTITION BY department) AS total_dept_salary, AVG(salary) FILTER (WHERE tenure > 5) OVER () AS avg_salary_senior FROM employees;
